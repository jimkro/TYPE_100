<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Typing Survival: Open World</title>
    <style>
        body {
            margin: 0;
            background: #050505;
            color: #eee;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        canvas {
            background: #1a1a1a;
            box-shadow: 0 0 40px rgba(0,0,0,0.8);
            border: 2px solid #555;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            width: 100%;
            text-shadow: 2px 2px 0 #000;
        }
        .highlight { color: #FFD700; font-weight: bold;}
        .bomb-text { color: #FF4500; font-weight: bold;}
    </style>
</head>
<body>

<div id="ui">
    <h2>打字生存: 開放世界</h2>
    <p>移動: up, down, left, right | 攻擊: 輸入頭上單字</p>
    <p>道具: 輸入 <span class="bomb-text">BOMB</span> 字串清除視野怪物</p>
    <h3>分數: <span id="scoreDisplay">0</span> | 生命: <span id="hpDisplay">100</span>%</h3>
</div>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const hpDisplay = document.getElementById('hpDisplay');

    // --- 1. 世界與鏡頭設定 ---
    const WORLD_WIDTH = 2000;  // 世界總寬度
    const WORLD_HEIGHT = 2000; // 世界總高度
    
    // 鏡頭 (Camera) 物件
    const camera = { x: 0, y: 0 };

    // --- 2. 遊戲狀態 ---
    let score = 0;
    let currentInput = "";
    let gameOver = false;
    let flashScreen = 0; // 爆炸閃光計時器

    const player = {
        x: WORLD_WIDTH / 2,
        y: WORLD_HEIGHT / 2,
        size: 30,
        hp: 100,
        speed: 80,
        color: '#00d2ff'
    };

    let enemies = [];
    let items = []; // 道具陣列
    let effects = []; // 文字特效

    // 單字庫
    const ENEMY_WORDS = ['bug', 'lag', '404', 'null', 'fail', 'deny', 'slow', 'halt', 'kill', 'die', 'dos', 'cmd'];
    const BOMB_WORDS = ['boom', 'nuke', 'blast', 'clear', 'bomb']; // 炸彈專用字

    // --- 3. 核心邏輯 ---

    // 更新鏡頭位置 (讓玩家保持在畫面中心，但不要超出地圖邊界)
    function updateCamera() {
        camera.x = player.x - canvas.width / 2;
        camera.y = player.y - canvas.height / 2;

        // 邊界限制 (Clamping)
        camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - canvas.width));
        camera.y = Math.max(0, Math.min(camera.y, WORLD_HEIGHT - canvas.height));
    }

    // 生成物件
    function spawnEntity() {
        // 隨機生成怪物
        if (Math.random() < 0.03) { 
            // 在玩家周圍一定距離外生成，避免直接生在臉上
            let ex, ey;
            let dist;
            do {
                ex = Math.random() * WORLD_WIDTH;
                ey = Math.random() * WORLD_HEIGHT;
                dist = Math.hypot(ex - player.x, ey - player.y);
            } while (dist < 400); // 至少距離 400 像素

            enemies.push({
                x: ex, y: ey, size: 25,
                word: ENEMY_WORDS[Math.floor(Math.random() * ENEMY_WORDS.length)],
                speed: 1 + Math.random(),
                color: '#ff3333'
            });
        }

        // 隨機生成炸彈道具 (機率較低)
        if (Math.random() < 0.005 && items.length < 3) {
            items.push({
                x: Math.random() * WORLD_WIDTH,
                y: Math.random() * WORLD_HEIGHT,
                size: 20,
                type: 'bomb',
                word: BOMB_WORDS[Math.floor(Math.random() * BOMB_WORDS.length)],
                color: '#FFA500' // 橘色
            });
        }
    }

    // 指令移動
    const MOVEMENT = {
        'up':    () => player.y = Math.max(0, player.y - player.speed),
        'down':  () => player.y = Math.min(WORLD_HEIGHT - player.size, player.y + player.speed),
        'left':  () => player.x = Math.max(0, player.x - player.speed),
        'right': () => player.x = Math.min(WORLD_WIDTH - player.size, player.x + player.speed)
    };

    // 輸入處理
    window.addEventListener('keydown', (e) => {
        if (gameOver) return;
        if (e.key === 'Backspace') currentInput = currentInput.slice(0, -1);
        else if (/^[a-zA-Z]$/.test(e.key)) currentInput += e.key.toLowerCase();
        
        checkInput();
    });

    function checkInput() {
        // 1. 檢查移動
        if (MOVEMENT[currentInput]) {
            MOVEMENT[currentInput]();
            currentInput = "";
            return;
        }

        // 2. 檢查道具 (優先於怪物，因為道具通常是救命的)
        const itemIndex = items.findIndex(i => i.word === currentInput);
        if (itemIndex !== -1) {
            useItem(items[itemIndex]);
            items.splice(itemIndex, 1);
            currentInput = "";
            return;
        }

        // 3. 檢查怪物
        const enemyIndex = enemies.findIndex(e => e.word === currentInput);
        if (enemyIndex !== -1) {
            // 檢查該怪物是否在螢幕範圍內 (可選：全地圖攻擊太強，限制視野內才算)
            const e = enemies[enemyIndex];
            // 簡單判定：只要存在就殺
            createEffect(e.word.toUpperCase(), e.x, e.y, '#ff0');
            enemies.splice(enemyIndex, 1);
            score += 10;
            scoreDisplay.textContent = score;
            currentInput = "";
        }
    }

    // 道具效果：炸彈
    function useItem(item) {
        if (item.type === 'bomb') {
            // 視覺效果：閃光
            flashScreen = 10; 
            createEffect("BOOM!", player.x, player.y - 50, '#fff', 30);
            
            // 邏輯：清除「視野內」的怪物
            // 視野範圍定義：Camera x/y 到 Camera x/y + canvas w/h
            const oldEnemyCount = enemies.length;
            enemies = enemies.filter(e => {
                const onScreen = e.x > camera.x && e.x < camera.x + canvas.width &&
                                 e.y > camera.y && e.y < camera.y + canvas.height;
                if (onScreen) {
                    createEffect("+KILL", e.x, e.y, '#f00');
                    score += 5; // 炸死的給分較少
                }
                return !onScreen; // 留下的怪物是「不在螢幕上」的
            });
            
            scoreDisplay.textContent = score;
        }
    }

    function createEffect(text, x, y, color, size=20) {
        effects.push({text, x, y, color, life: 40, size});
    }

    // --- 4. 繪圖輔助 ---
    
    // 繪製小地圖
    function drawMinimap() {
        const mapSize = 150; // 小地圖顯示尺寸 (px)
        const margin = 20;
        const mapX = canvas.width - mapSize - margin;
        const mapY = margin;
        
        // 背景
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.fillRect(mapX, mapY, mapSize, mapSize);
        ctx.strokeRect(mapX, mapY, mapSize, mapSize);

        // 比例尺
        const scaleX = mapSize / WORLD_WIDTH;
        const scaleY = mapSize / WORLD_HEIGHT;

        // 畫道具 (黃點)
        ctx.fillStyle = '#FFA500';
        items.forEach(i => {
            ctx.beginPath();
            ctx.arc(mapX + i.x * scaleX, mapY + i.y * scaleY, 3, 0, Math.PI*2);
            ctx.fill();
        });

        // 畫怪物 (紅點)
        ctx.fillStyle = '#ff3333';
        enemies.forEach(e => {
            ctx.fillRect(mapX + e.x * scaleX, mapY + e.y * scaleY, 2, 2);
        });

        // 畫玩家 (藍點)
        ctx.fillStyle = '#00d2ff';
        ctx.beginPath();
        ctx.arc(mapX + player.x * scaleX, mapY + player.y * scaleY, 4, 0, Math.PI*2);
        ctx.fill();

        // 畫視野框 (View Rect) - 讓你知道你在世界的哪裡
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(
            mapX + camera.x * scaleX, 
            mapY + camera.y * scaleY, 
            canvas.width * scaleX, 
            canvas.height * scaleY
        );
    }

    // --- 5. 遊戲主迴圈 ---
    function gameLoop() {
        if (gameOver) {
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = 'red';
            ctx.font = '40px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
            return;
        }

        // 更新邏輯
        updateCamera();
        spawnEntity();
        
        // 敵人追蹤與碰撞
        enemies.forEach(e => {
            const dx = player.x - e.x;
            const dy = player.y - e.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 0) {
                e.x += (dx / dist) * e.speed;
                e.y += (dy / dist) * e.speed;
            }
            // 碰撞扣血
            if (dist < player.size) {
                player.hp -= 0.5;
                hpDisplay.textContent = Math.floor(player.hp);
                if(player.hp <= 0) gameOver = true;
            }
        });

        // --- 繪圖開始 ---
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // [重要] 儲存畫布狀態，並平移到鏡頭位置
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // 1. 繪製世界邊界
        ctx.strokeStyle = '#f00';
        ctx.lineWidth = 5;
        ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

        // 2. 繪製地板網格 (參考)
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        for(let x=0; x<=WORLD_WIDTH; x+=100) {
            // 優化：只畫視野內的線
            if(x >= camera.x - 100 && x <= camera.x + canvas.width + 100) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, WORLD_HEIGHT); ctx.stroke();
            }
        }
        for(let y=0; y<=WORLD_HEIGHT; y+=100) {
            if(y >= camera.y - 100 && y <= camera.y + canvas.height + 100) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WORLD_WIDTH, y); ctx.stroke();
            }
        }

        // 3. 繪製道具
        items.forEach(i => {
            // 繪製光暈
            ctx.shadowBlur = 10;
            ctx.shadowColor = i.color;
            ctx.fillStyle = i.color;
            ctx.fillRect(i.x, i.y, i.size, i.size);
            ctx.shadowBlur = 0; // 重置

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText("[" + i.word + "]", i.x + i.size/2, i.y - 5);
        });

        // 4. 繪製敵人
        enemies.forEach(e => {
            // 優化：只繪製螢幕內的敵人 (Culling)
            if(e.x < camera.x - 50 || e.x > camera.x + canvas.width + 50 ||
               e.y < camera.y - 50 || e.y > camera.y + canvas.height + 50) return;

            ctx.fillStyle = e.color;
            ctx.fillRect(e.x, e.y, e.size, e.size);
            
            ctx.fillStyle = '#FFD700';
            ctx.font = '16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(e.word, e.x + e.size/2, e.y - 5);
        });

        // 5. 繪製玩家
        ctx.fillStyle = player.color;
        ctx.fillRect(player.x, player.y, player.size, player.size);
        
        // 玩家輸入框
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(player.x - 20, player.y - 40, 70, 25);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(currentInput, player.x + player.size/2, player.y - 20);

        // 6. 繪製特效
        effects.forEach((eff, i) => {
            ctx.fillStyle = eff.color;
            ctx.font = `bold ${eff.size}px Courier New`;
            ctx.fillText(eff.text, eff.x, eff.y);
            eff.y -= 1;
            eff.life--;
            if(eff.life <= 0) effects.splice(i, 1);
        });

        // [重要] 恢復畫布狀態 (為了畫固定的 UI/小地圖)
        ctx.restore();

        // 爆炸閃光
        if (flashScreen > 0) {
            ctx.fillStyle = `rgba(255, 255, 255, ${flashScreen/10})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            flashScreen--;
        }

        // 7. 繪製小地圖 (固定在右上角)
        drawMinimap();

        requestAnimationFrame(gameLoop);
    }

    gameLoop();

</script>
</body>
</html>